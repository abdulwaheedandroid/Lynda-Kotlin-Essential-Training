Boolean and char data types
- [Instructor] Kotlin provides us the char and boolean types for working with character and boolean data. Let's begin by checking out char. Declaring a character is simple. It is like any other declaration except it specifies the char type and encloses its data in single quotes. We can also encode ASCII data by using the backslash escape sequence, and there is support for unicode characters with the backslash U encoding scheme. Let's create a few character variables. So we say val_letter, colon, Char, equals, single quotes, A. Let's infer an ASCII character. So we say val_tab equals, single quotes, \t, and this is going to be the tab character. We can create unicode characters as well. So we say val_infinity equals, single quotes, backslash, small U, 221 and then capital E. And let's go ahead and print out our characters, so we're going to say print line and we do double quotes letter equals dollar sign letter. Then we say print line double quotes, tabbed, then a space, dollar sign, tab, another space and then over. Let's move up the screen just a tad. And then we'll go print line, double quotes infinity, equals, dollar sign, infinity. Keep in mind that Kotlin never does implicit conversions, and that characters are not numbers. Conversion methods can convert to and from character types. So we'll say that val_lineFeed equals the number 10 .toChar. We'll do a print line, double quotes, line feed, equals, dollar sign line feed, space, next line. And, let's uncomment the line demoChar and run the code. And, everything looks as expected, including the line feed, which caused the line to break. We have a printing of the infinity character and we can see that our tab has tabbed over on the second line. The boolean data type is also simple to declare. A boolean can have one of two values, true or false. So let's go in here and comment out demoChar and comment in demoBoolean and right inside the demoBoolean, we will say var willExercise, colon Boolean, equals false. Now we can shorten the declaration using inference and because we're already saying that it's equal false, we don't need the boolean, so we'll delete that and we'll delete the colon. We can also assign a boolean the results of a logical expression. So, we'll say that val bigNumber equals one, underscore 000, underscore 000, so bigNumber equals one million, val smallNumber, equals two, and then, what we'll do is we do a print line and say is big bigger and say equals dollar sign curly braces and inside of here, we'll do a logical expression, bigNumber greater than smallNumber. And let's go ahead and run the code and we get is big bigger and it prints out a boolean true. The or operation returns true if either operand is true. It also short circuits. A short circuit means it doesn't evaluate the second operand if the first returns true, hence the name lazy disjunction. It is lazy because it only does as much work as necessary. Programmers sometimes assume both operands are always evaluated and find this behavior surprising. So it occasionally causes bugs. The and operation returns false if either operand is false. If the first operand returns false, the operation short circuits and the second operand is not evaluated. So near the top of the file, there are two functions, first operand and second operand, which return false and true, respectively. If we place first and second operand into a logical or expression, both operands are executed. So what we're going to say here is if first operand and then we do an or, which is the pipe symbol twice, and then we do second operand. Both of these operands will execute because the first operand returns false and so it needs to check the second operand to see if it returns true. And so we can print here, print line, at least one operand is true. Now, when we place them into an and logical expression, only the first is evaluated because first operand returns false, making the entire expression false. So we can take this guy, we can copy him and place him below and we place the or symbol with the and symbol, which is the double ampersands, and then we need to change this expression because both operands have to be true for an and to be true. And finally, we can negate any boolean symbol by placing an exclamation point in front of it. So we'll say print line, will exercise, equals dollar sign curly brace, exclamation point, will exercise. And let's run the code and we get the results as expected. We've got both of the operands were executed for the or operation and so we got the message at least one operand is true. For the and operation, we see that the first operand executed because it returned false, the whole expression is now false, so the second operand did not evaluate. And finally, we get will exercise turns from false to true because we put the negation on it. And this has been a look at the char and boolean data types. The Kotlin online documentation has more information if you need it.