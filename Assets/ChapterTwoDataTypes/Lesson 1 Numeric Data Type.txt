Numeric data types
- [Instructor] To create a variable in Kotlin, begin with the val or var keyword. So we're going to come up here and we're going to say var, then the name which is count, a colon, the type which is going to be Int, the equal sign and then a value which is going to be zero. The var keyword creates a mutable variable. One you can change. The keyword val creates an immutable variable. Its value is settable only once. Using immutable variables is a programing best practice so declare them whenever you can. So let's create a val. So val number: Int and we're going to say equals 42. Some parts of the variable declaration are optional. If you assign a value to a variable, usually its type can be inferred so you can omit it. So we'll have val otherNumber equals 43. Kotlin has four integers in a range of sizes. The default type is Int which is 32 bits and has a rough range of plus or minus two billion. If you omit the type declaration and the number falls within this range, then Int is inferred. The Int has a 64 bits big brother, the Long. The final two integer types are Byte and Short which have eight and 16 bits repetitively. Kotlin never infers these two since they are in the Int range. If you want them, you've got to ask. So let's declare a Long. We're going to say value myLong. And colon Long. And it equals 3000000000, give it a bunch of zeros and an L to specify that it is a Long. For Byte, it's val myByte: Byte equals 127. Then we'll have val myShort: Short equals 32767. In addition to integers, Kotlin has two floating point types, the float and the double which is the default. If you want the 32 bits float, you must specify it and append an F to the number. So let's create a Double. Value myDouble: Double equals 98.6. And for a floating point, we're going to say val myFloat: Float equals 12.2 and then we need to put an F. And let's create one more Double. Val alsoDouble equals 101.5. Kotlin is very picky about number types. It won't automatically widen numbers like most languages. If a function takes a long, you can't send it an int, even though such a translation is usually safe. Luckily, every number also supports quite a few conversion methods. So we have val asInt and we're going to say alsoDouble.toInt and so that's going to turn our double into an integer and we say val asFloat and equals myLong.toFloat. One surprisingly helpful convenience is the support of underscores as number spacers, especially when I have large numbers, the underscores make it much easier to enter the values correctly. So let's enter maximum Int, so that's going to be val maxInt equals 2_147_483_648. Kotlin supports hexadecimal, binary, and long constants. At a capital L to the end of a number to make it a long. Prepend a number with 0x for hexadecimal or 0b for binary. Like all modern languages, Kotlin has robust support for a variety of numeric data types. If you'd like more information, please check out the Kotlin online documentation.